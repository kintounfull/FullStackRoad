(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{358:function(e,t,r){"use strict";r.r(t);var a=r(25),i=Object(a.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("p",[e._v("Hybrid Web可以提供Native和Web的混合开发方案，比如在弱交互场景下使用Hybrid Web，在强交互场景下使用Native，在牺牲少量交互的前提下，提高整体开发效率。")]),e._v(" "),r("p",[e._v("开发思路大致如下：")]),e._v(" "),r("ol",[r("li",[e._v("实现Native与Javascript相互通信")]),e._v(" "),r("li",[e._v("实现WebView容器")]),e._v(" "),r("li",[e._v("定义API，实现对应的功能")]),e._v(" "),r("li",[e._v("提升交互体验，例如离线方案等")]),e._v(" "),r("li",[e._v("WebView和通信机制均以API 19作为分界点实现两种不同方案\n1）API 19以前WebView不基于Chromium"),r("br"),e._v("\n2）API 17以前J2N会安全漏洞，API 19以前N2J没有回调不能直接获取调用结果")])]),e._v(" "),r("h1",{attrs:{id:"_1-native-javascript"}},[e._v("1. Native <--\x3e Javascript")]),e._v(" "),r("p",[e._v("Hybrid Web在利用Web高开发效率时，可以让Web调用Native的部分功能，通过Native来提高Web业务场景下的交互友好度。因此，开发Hybrid Web的第一步就是打通Native和Web间的通信。")]),e._v(" "),r("h2",{attrs:{id:"_1-1-native调用js"}},[e._v("1.1. Native调用JS")]),e._v(" "),r("p",[e._v("Native调用Javascript的方法有"),r("code",[e._v("WebView.loadUrl()")]),e._v("和"),r("code",[e._v("WebView.evaluateJavascript()")]),e._v("两种。")]),e._v(" "),r("h3",{attrs:{id:"_1-1-1-void-loadurl-javascript-function"}},[e._v('1.1.1. void loadUrl("javascript://function(...);")')]),e._v(" "),r("p",[e._v("loadUrl支持所有版本，兼容性高，但该机制存在多个缺陷：")]),e._v(" "),r("ul",[r("li",[e._v("Android无法获取Js方法的返回值（iOS可以），同步态")]),e._v(" "),r("li",[e._v("Android无法通过回调接口注册回调方法（iOS可以？？？），异步态")]),e._v(" "),r("li",[e._v("Native调用的JS方法必须在访问的JS脚本中实现，但即使没有实现也不会报错")]),e._v(" "),r("li",[e._v("会刷新页面？？？")])]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('# Java\nWebView webview = findViewById(R.id.webView);\nwebview.loadUrl("javascript://show(\'test\');");\nwebview.loadUrl("javascript://showReturn(\'test\');");\nwebview.loadUrl("javascript://showCallback(\'test\', callback);");\n\n# Javascript\n<script language=javascript>\n   function show(str) {\n      alert(str);\n   }\n    \n   # Android无法获取Js方法的返回值。\n   # 因此，Native无法收到同步返回值“result”\n   function showReturn(str) {\n      return "result";\n   }\n   \n   # Android无法通过回调接口注册回调方法。\n   # 因此，Native注册的callback回调方法没用。\n   function showCallback(str, callback) {\n       alert(str);\n       callback("result");\n   }\n<\/script>\n')])])]),r("h3",{attrs:{id:"_1-1-2-void-evaluatejavascript-script-resultcallback"}},[e._v("1.1.2. void evaluateJavascript(script, resultCallback)")]),e._v(" "),r("p",[e._v("evaluateJavascript是Android在Kitkat（4.4 API 19）才引入的接口。该接口可以解决"),r("code",[e._v("loadUrl()")]),e._v("无法注册回调的缺陷，同时性能更好，也不会刷新页面。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('webView.evaluateJavascript("javascript:" + name + "(" + jsonString + ")", new ValueCallback<String>() {\n    @Override\n    public void onReceiveValue(String value){\n\n    }\n});\n')])])]),r("h3",{attrs:{id:"_1-1-3-对比"}},[e._v("1.1.3. 对比")]),e._v(" "),r("table",[r("thead",[r("tr",[r("th",[e._v("方法")]),e._v(" "),r("th",[e._v("优势")]),e._v(" "),r("th",[e._v("劣势")])])]),e._v(" "),r("tbody",[r("tr",[r("td",[e._v("loadUrl")]),e._v(" "),r("td",[e._v("支持所有版本")]),e._v(" "),r("td",[e._v("1. 性能更差"),r("br"),e._v("2. 不支持注册回调"),r("br"),e._v("3. 会刷新页面")])]),e._v(" "),r("tr",[r("td",[e._v("evaluateJavascript")]),e._v(" "),r("td",[e._v("1. 性能更高"),r("br"),e._v("2. 支持注册回调")]),e._v(" "),r("td",[e._v("仅支持Kitkat (4.4 API 19)及更新版本")])])])]),e._v(" "),r("h2",{attrs:{id:"_1-2-js调用native"}},[e._v("1.2. JS调用Native")]),e._v(" "),r("p",[e._v("Javascript调用Native的方法目前主要有三种：")]),e._v(" "),r("ul",[r("li",[e._v("注入API")]),e._v(" "),r("li",[e._v("拦截URL Scheme")]),e._v(" "),r("li",[e._v("拦截Prompt")])]),e._v(" "),r("h3",{attrs:{id:"_1-2-1-注入api-js上下文注入"}},[e._v("1.2.1 注入API（JS上下文注入）")]),e._v(" "),r("p",[e._v("WebView提供了"),r("code",[e._v("addJavascriptInterface(interfaceObject, interfaceName)")]),e._v("方法（WebKit的原生API）来向JS暴露Native的API，可供JS调用访问。但该接口在API 17（Android 4.2）之前存在"),r("RouterLink",{attrs:{to:"/Android/Hybrid/你不知道的WebView使用漏洞.html"}},[e._v("安全漏洞")]),e._v("（若需要支持老版本的系统，不推荐使用该方案）。因此，为了规避这些安全漏洞，自API 17开始，Android默认限制了"),r("code",[e._v("addJavascriptInterface")]),e._v("中添加的方法的访问，需要通过注解"),r("code",[e._v("@JavascriptInterface")]),e._v("标注方法以后才能使用。")],1),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('# Java\n@SuppressLint("JavascriptInterface")\npublic class JsInterfaces {\n    @JavascriptInterface\n    public void showToast(String msg) {\n        Toast.makeText(getContext(), text, Toast.LENGTH_SHORT).show();\n    }\n\n    @JavascriptInterface\n    public void showLoading() {\n        if (mLoadingView != null) {\n            mLoadingView.showLoading();\n        }\n    }\n}\n\nWebView webview = findViewById(R.id.webView);\nwebview.getSettings().setJavaScriptEnabled(true);\nwebview.addJavascriptInterface(new JsInterfaces(), "native");\nwebview.loadUrl(xxx://xxx.html);\n\n# Javascript\nnative.showLoading()\n')])])]),r("h3",{attrs:{id:"_1-2-2-拦截url-scheme"}},[e._v("1.2.2. 拦截URL Scheme")]),e._v(" "),r("p",[e._v("Hybrid强调Android和iOS共用一套Web代码，因此，其基础控件需要处理不同系统间的差异，以及原生系统机制存在的缺陷。由此诞生了一些方案来优化和解决原生系统的默认方案。")]),e._v(" "),r("p",[e._v("一个主流的方案是利用URL可拦截的机制，预先设定特定URL关键字与功能的映射MAP，在拦截URL时解析Scheme匹配对应的API。JavascriptBridge和Route是基于该机制实现的两类方案。")]),e._v(" "),r("h4",{attrs:{id:"_1-2-2-1-jsbridge"}},[e._v("1.2.2.1. JsBridge")]),e._v(" "),r("p",[e._v("大神Marcus Westin开源了一套用于iOS和OSX上的通信方案"),r("a",{attrs:{href:"https://github.com/marcuswestin/WebViewJavascriptBridge",target:"_blank",rel:"noopener noreferrer"}},[e._v("marcuswestin/WebViewJavascriptBridge"),r("OutboundLink")],1),e._v("，目前Facebook等多家公司都应用了该方案。")]),e._v(" "),r("blockquote",[r("p",[e._v("An iOS/OSX bridge for sending messages between Obj-C and JavaScript in UIWebViews/WebViews")])]),e._v(" "),r("p",[e._v("Android下同类方案中最火的开源项目是"),r("a",{attrs:{href:"https://github.com/lzyzsd/JsBridge",target:"_blank",rel:"noopener noreferrer"}},[e._v("lzyzsd/JsBridge"),r("OutboundLink")],1),e._v("。在作者的描述中，其灵感来自于微信的webview jsbridge方案WeiXinJSBridge（现在被封装成JSSDK）。")]),e._v(" "),r("blockquote",[r("p",[e._v("android java and javascript bridge, inspired by wechat webview jsbridge")])]),e._v(" "),r("p",[e._v("不清楚Bridge的方案最新起源与哪儿？")]),e._v(" "),r("p",[e._v("没有完整看过"),r("strong",[e._v("marcuswestin/WebViewJavascriptBridge")]),e._v("，但从网上博客中看到，其实现原理和用法与"),r("strong",[e._v("lzyzsd/JsBridge")]),e._v("基本一致，差异主要在JS加载时机不同；以及iOS的Native可以获取Js方法的返回值，Android不行，参见"),r("a",{attrs:{href:"https://www.jianshu.com/p/c565c8f93abd",target:"_blank",rel:"noopener noreferrer"}},[e._v("聊一聊WebView与JS交互方案 - 适用Android & iOS"),r("OutboundLink")],1),e._v("。")]),e._v(" "),r("p",[e._v("差异部分关键代码如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("# iOS - marcuswestin/WebViewJavascriptBridge\nfunction _fetchQueue() {\n   var messageQueueString = JSON.stringify(sendMessageQueue);\n   sendMessageQueue = [];\n   return messageQueueString;\n}\n\n# Andrid - lzyzsd/JsBridge\nfunction _fetchQueue() {      \n   var messageQueueString = JSON.stringify(sendMessageQueue);        \n   sendMessageQueue = [];    \n   // return messageQueueString;        \n   // Android无法直接返回数据, 这是与iOS最大的区别; 所以, 需要使用自定义url形式返回数据。     \n   messagingIframe.src = CUSTOM_PROTOCOL_SCHEME + '://return/_fetchQueue/' + encodeURIComponent(messageQueueString);   \n}\n")])])]),r("blockquote",[r("p",[e._v("注："),r("strong",[e._v("marcuswestin/WebViewJavascriptBridge")]),e._v("定义的JS API文件是"),r("code",[e._v("./WebViewJavascriptBridge/WebViewJavascriptBridge_JS.m")])])]),e._v(" "),r("p",[e._v("因此，先直接从"),r("strong",[e._v("lzyzsd/JsBridge")]),e._v("入手，搞明白其原理，再根据两者定义的JS API，扩展出自己的通信方案和API。")]),e._v(" "),r("p",[e._v("JsBridge，通过"),r("code",[e._v("WebViewClient.shouldOverrideUrlLoading(webview, url)")]),e._v("中拦截特定URL，解析匹配对应的Native API，代表开源项目。")]),e._v(" "),r("h4",{attrs:{id:"_1-2-2-2-router"}},[e._v("1.2.2.2. Router")]),e._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"https://github.com/douban/rexxar-android",target:"_blank",rel:"noopener noreferrer"}},[e._v("Route"),r("OutboundLink")],1)])]),e._v(" "),r("h4",{attrs:{id:"_1-2-2-3-对比"}},[e._v("1.2.2.3 对比")]),e._v(" "),r("h3",{attrs:{id:"_1-2-3-拦截prompt"}},[e._v("1.2.3 拦截Prompt")]),e._v(" "),r("p",[e._v("除了通过"),r("code",[e._v("WebViewClient.shouldOverrideUrlLoading()")]),e._v("拦截URL Scheme，还可以通过"),r("code",[e._v("WebChromeClient.onJsAlert")]),e._v("，或"),r("code",[e._v("WebChromeClient.onJsConfirm")]),e._v("，或"),r("code",[e._v("WebChromeClient.onJsPrompt")]),e._v("拦截Js弹窗，因alert和confirm较为常用，因此这种拦截模式通常用prompt。")]),e._v(" "),r("blockquote",[r("ul",[r("li",[e._v("WebChromeClient.onJsAlert，对应于js的alert(警告框)")]),e._v(" "),r("li",[e._v("WebChromeClient.onJsConfirm，对应于js的comfirm(确认框)")]),e._v(" "),r("li",[e._v("WebChromeClient.onJsPrompt，对应于js的prompt(提示框)")])])]),e._v(" "),r("p",[e._v("其具体实现原理与拦截URL Scheme类似，只是在不同的地方去拦截。")]),e._v(" "),r("h3",{attrs:{id:"_1-2-4-对比"}},[e._v("1.2.4 对比")]),e._v(" "),r("table",[r("thead",[r("tr",[r("th",[e._v("方式")]),e._v(" "),r("th",[e._v("优势")]),e._v(" "),r("th",[e._v("劣势")])])]),e._v(" "),r("tbody",[r("tr",[r("td",[e._v("注入API")]),e._v(" "),r("td",[e._v("官方接口，性能高")]),e._v(" "),r("td",[e._v("Android 4.2 (API 17)以下存在安全漏洞")])]),e._v(" "),r("tr",[r("td",[e._v("拦截URL Scheme")]),e._v(" "),r("td",[e._v("稳定，支持各种WebView")]),e._v(" "),r("td",[e._v("1. URL长度限制"),r("br"),e._v("2. 连续发送时消息丢失"),r("br"),e._v("3. URL拦截时延高")])]),e._v(" "),r("tr",[r("td",[e._v("拦截Prompt")]),e._v(" "),r("td"),e._v(" "),r("td",[e._v("1. iOS的UIWebView不支持，其WKWebView才支持"),r("br"),e._v("2. 性能相对注入API更低？")])])])]),e._v(" "),r("h2",{attrs:{id:"_1-3-自定义方案"}},[e._v("1.3 自定义方案")]),e._v(" "),r("p",[e._v("Native与JS相互通信方案的最佳组合是"),r("code",[e._v("evaluateJavascript")]),e._v(" + 注入API，但受限于Android的系统缺陷（注入API在Android 4.2 API 17以前有安全漏洞，evaluateJavascript从Android 4.4 API 19才开始支持），需要针对新老版本做取舍。")]),e._v(" "),r("p",[e._v("目前考虑采用混合方案。")]),e._v(" "),r("ol",[r("li",[e._v(">= Android 4.4 (API 19)，evaluateJavascript + 注入API")]),e._v(" "),r("li",[e._v("< Android 4.4 (API 19)，拦截URL Scheme（JsBridge or Route？？？）")])]),e._v(" "),r("p",[e._v("选择API 19作为分界线是为了简化代码的复杂度。截止2020-2-13，API 16～18的装机量为3.2%，数量很少，没必要为了这么少的用户数来提升代码的复杂度。")]),e._v(" "),r("h1",{attrs:{id:"参考资料"}},[e._v("参考资料")]),e._v(" "),r("p",[r("a",{attrs:{href:"https://awhisper.github.io/2018/01/02/hybrid-jscomunication/",target:"_blank",rel:"noopener noreferrer"}},[e._v("从零收拾一个hybrid框架（一）-- 从选择JS通信方案开始"),r("OutboundLink")],1)]),e._v(" "),r("p",[r("a",{attrs:{href:"https://www.jianshu.com/p/3a345d27cd42",target:"_blank",rel:"noopener noreferrer"}},[e._v("你不知道的Android WebView使用漏洞"),r("OutboundLink")],1)]),e._v(" "),r("p",[r("a",{attrs:{href:"https://juejin.im/post/58a037df86b599006b3fade4",target:"_blank",rel:"noopener noreferrer"}},[e._v("android WebView详解，常见漏洞详解和安全源码"),r("OutboundLink")],1)]),e._v(" "),r("p",[r("a",{attrs:{href:"https://www.jianshu.com/p/c565c8f93abd",target:"_blank",rel:"noopener noreferrer"}},[e._v("聊一聊WebView与JS交互方案 - 适用Android & iOS"),r("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=i.exports}}]);